// import { example1 as data } from './data';
import { Objeto } from './models';

// const PESO_LIMITE_MOCHILA = 30;

// This algorithm takes as input the weights and values of each item, the capacity of the knapsack, and
// the maximum number of iterations to run. It returns an object containing the solution with the
// highest total value found during the search.

// The algorithm works by generating a random initial solution and iteratively improving it using
// local search. In each iteration of local search, all possible neighbors are generated by flipping
// one item at a time. The modified solutions are evaluated based on their total weight and total value.
// If a valid neighbor with higher value is found than current solution then it becomes

// The local search process continues until no further improvement can be made or a certain number
// of iterations have passed. The entire process is repeated multiple times with different initial
// solutions to increase the chances of finding a good global solution.

// Overall this algorithm provides a simple but effective way to solve small instances of knapsack
// problem using iterative local search in TypeScript. For larger instances or more complex problems
//  other methods such as dynamic programming or heuristic algorithms may be more appropriate

/**
 * Solves the 0/1 knapsack problem using iterative local search.
 * @param weights The weights of each item.
 * @param values The values of each item.
 * @param maxIter The maximum number of iterations to run.
 */
export function ILS(
  data: Objeto[],
  maxIter: number,
  PESO_LIMITE_MOCHILA: number
): {
  solution: { value: number; weight: number };
} {
  const weights = data.map((obj) => obj.peso);
  const values = data.map((obj) => obj.valor);
  const n = weights.length;
  let bestSolution = new Array(n).fill(0);
  let bestValue = 0;
  let bestWeight = 0;

  for (let i = 0; i < maxIter; i++) {
    // Generate a random initial solution.
    const currentSolution = new Array(n)
      .fill(0)
      .map(() => Math.round(Math.random()));

    // Perform local search on the initial solution with disturbance
    let currentSol = evaluateSolution(
      currentSolution,
      weights,
      values,
      PESO_LIMITE_MOCHILA
    );
    while (true) {
      const neighbors = [];
      for (let j = 0; j < n; j++) {
        const neighbor = currentSolution.slice();
        neighbor[j] = neighbor[j] === 1 ? 0 : 1;
        neighbors.push(neighbor);
      }

      let bestNeighborValue = -1;
      let bestNeighbor;
      for (const neighbor of neighbors) {
        const newSolution = evaluateSolution(
          neighbor,
          weights,
          values,
          PESO_LIMITE_MOCHILA
        );
        if (newSolution.value > bestNeighborValue) {
          bestNeighborValue = newSolution.value;
          bestNeighbor = neighbor.slice();
        }
      }

      if (!bestNeighbor || bestNeighborValue <= currentSol.value) break;

      currentSolution.splice(0, currentSolution.length, ...bestNeighbor);
      currentSol.value = bestNeighborValue;
    }

    // Update the global solution if necessary.
    if (currentSol.value > bestValue) {
      bestSolution.splice(0, bestSolution.length, ...currentSolution);
      bestValue = currentSol.value;
      bestWeight = currentSol.weight;
    }

    // Disturbance
    for (let j = 0; j < n; j++) {
      if (Math.random() < 0.5) {
        continue;
      }

      const disturbedSoln = bestSolution.slice();

      disturbedSoln[j] = disturbedSoln[j] === 1 ? 0 : 1;

      const disturbedSol = evaluateSolution(
        disturbedSoln,
        weights,
        values,
        PESO_LIMITE_MOCHILA
      );

      if (disturbedSol.value > bestValue) {
        return {
          solution: { weight: disturbedSol.weight, value: disturbedSol.value },
        };
      }
    }
  }

  return { solution: { weight: bestWeight, value: bestValue } };
}

/**
 * Evaluates a given solution by computing its total value and checking whether it exceeds the capacity.
 */
function evaluateSolution(
  solution: number[],
  weights: number[],
  values: number[],
  PESO_LIMITE_MOCHILA: number
): { value: number; weight: number } {
  const weightSum = solution.reduce(
    (sum, val, index) => sum + val * weights[index],
    0
  );

  // If weight exceeds capacity then return -1
  if (weightSum > PESO_LIMITE_MOCHILA) {
    return {
      value: -1,
      weight: -1,
    };
  }

  return {
    weight: weightSum,
    value: solution.reduce((sum, val, index) => sum + val * values[index], 0),
  };
}

// const solution = ILS([...data], 10000, PESO_LIMITE_MOCHILA).solution;

// console.log(solution);
